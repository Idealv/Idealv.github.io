<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Idealv的杂七杂八</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Idealv的杂七杂八">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Idealv的杂七杂八">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Idealv的杂七杂八">
  
    <link rel="alternate" href="/atom.xml" title="Idealv的杂七杂八" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Idealv的杂七杂八</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-redis-note-ch3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/18/redis-note-ch3/" class="article-date">
  <time datetime="2019-09-18T10:43:34.000Z" itemprop="datePublished">2019-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/18/redis-note-ch3/">《Redis开发与运维》第三章笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第三章-小功能大用处"><a href="#第三章-小功能大用处" class="headerlink" title="第三章 小功能大用处"></a>第三章 小功能大用处</h1><p>本章讲了很多redis的附加功能，这里只列出个人认为比较实用的功能</p>
<ul>
<li>慢查询优化</li>
<li>redis shell</li>
<li>Pipeline</li>
<li>事务与Lua</li>
<li>Bitmaps</li>
<li>发布订阅</li>
</ul>
<h2 id="3-1-慢查询优化"><a href="#3-1-慢查询优化" class="headerlink" title="3.1.慢查询优化"></a>3.1.慢查询优化</h2><p><strong>慢查询日志:</strong></p>
<p>系统计算命令执行所耗费的时间，当这个时间超过了预设阈值，就将这条命令的信息写入慢查询日志中</p>
<p><strong>一条客户端命令的生命周期为：</strong></p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>redis的慢查询机制只查询第三步前后耗费的时间，所以没有慢查询问题不代表没有超时问题</p>
<h3 id="3-1-1-慢查询的两个参数配置"><a href="#3-1-1-慢查询的两个参数配置" class="headerlink" title="3.1.1.慢查询的两个参数配置"></a>3.1.1.慢查询的两个参数配置</h3><ol>
<li>预设阈值:slowlog-log-slower-than(slowlog-max-len:说明了慢查询日志能存储多少条)</li>
<li>慢查询日志存放位置:存放在redis的一个列表里,如果日志条数超过slowlog-max-len则队头出队，队尾入队</li>
</ol>
<p><strong><em>修改参数配置</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config set slowlog-log-slower-than xx</span><br><span class="line">config set slowlog-max-len xx</span><br><span class="line">config rewrite</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">***获取慢查询日志***</span><br></pre></td></tr></table></figure></p>
<p>slowlog get [n] //虽然慢查询日志存放在redis中的一个列表中，但redis并没有暴露这个列表的key(n指定条数)<br>slowlog len //获取slowlog当前长度<br>slowlog reset //重置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***慢查询日志 日志项属性***</span><br></pre></td></tr></table></figure></p>
<p>//伪代码标识<br>slowlog [<br>    {<br>        “标识id”:””,<br>        “发生时间戳”:tiemstamp,<br>        “命令耗时”:timestamp,<br>        “执行命令和参数”:””<br>    },<br>    {<br>        …<br>    }<br>]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***最佳实践***</span><br><span class="line">- slowlog-max-len:建议配置为1000以上</span><br><span class="line">- slowlog-log-slower-than:默认值为10ms，对于高流量场景建议设置为1ms</span><br><span class="line"></span><br><span class="line">## 3.2.reids shell</span><br><span class="line">了解redis cli的一些重要参数</span><br><span class="line">1. -r:重复命令，知道到达指定次数</span><br></pre></td></tr></table></figure></p>
<pre><code>$ redis-cli -r 3 ping
PONG
PONG
PONG
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. -i:每隔几秒执行一次命令,必须要和-r一起使用</span><br></pre></td></tr></table></figure>

redis-cli -r 5 -i 1 ping //每隔1秒执行一次，一共执行5次
PONG
PONG
PONG
PONG
PONG
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. -x:从stdin读取数据作为redis-cli最后的参数</span><br></pre></td></tr></table></figure>

echo &quot;world&quot; | redis-cli -x set hello
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.3.Pipeline</span><br><span class="line">***RTT:往返时间***</span><br><span class="line"></span><br><span class="line">批量操作可以减少RTT，但并不是所有的数据结构都支持批量操作的，所以通过Pipeline技术将多条redis命令转换为一条命令，</span><br><span class="line">将这条命令发给redis server，然后再将返回的结果依次返回给客户端,一般来说通过客户端来使用Pipeline.</span><br><span class="line"></span><br><span class="line">## 3.4.事务与Lua</span><br><span class="line"></span><br><span class="line">### 3.4.1.Redis中的事务</span><br><span class="line">事务的概念不再重复，直接来看redis中的事务</span><br></pre></td></tr></table></figure>
</code></pre><p>multi //事务开始<br>exec //事务结束<br>discard //停止事务执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在两条命令间执行的命令都不会真正的执行(返回QUEUED),而是保存在redis中,只有提交事务后才会真正得到执行</span><br><span class="line"></span><br><span class="line">***Redis事务的局限性:***</span><br><span class="line">1. 命令错误:如果命令产生了语法错误，整个事务都无法执行</span><br><span class="line">2. 运行时错误:如果写错了命令(例如把sadd写成了zadd)，提交事务时会发生错误，但redis不支持回滚，需要手动修改错误</span><br><span class="line"></span><br><span class="line">### 3.4.2.Lua基本用法</span><br><span class="line">***数据类型:***</span><br><span class="line"></span><br><span class="line">booleans,numbers,strings,tables(表格)</span><br></pre></td></tr></table></figure></p>
<p>local strings val=”worlds”<br>local tables myArr={“redis”,1,true}</p>
<p>local int sum=0;<br>for i=1,100<br>do<br>    sum+=i<br>end</p>
<hr>
<p>for i=1,#myArr<br>do<br>    print(myArr[i])</p>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>— ipairs<br>for index,value in ipairs(myArr)<br>do<br>    print(index)<br>    print(value)<br>end</p>
<p>— while循环<br>while …<br>do<br>    …<br>end</p>
<p>— if else<br>if …<br>then<br>   …<br>else<br>   …<br>end</p>
<p>— hash<br>local tables user_1={age=28,name=”xiaoming”}</p>
<p>— function<br>fucntion funcName()<br>    …<br>end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.4.3.在Redis中使用Lua</span><br><span class="line">1. eval</span><br></pre></td></tr></table></figure></p>
<pre><code>eval &apos;return &quot;hello &quot; .. KEYS[1] .. ARGV[1]&apos; 1(key的个数) redis world
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    如果脚本较长可以用redi-cli --eval直接执行文件</span><br><span class="line"></span><br><span class="line">2. evalsha:将Lua脚本加载到redis server中，返回该脚本的sha校验和，通过校验和可以直接执行对于脚本，增加复用性</span><br></pre></td></tr></table></figure>

redis-cli script load &quot;${cat lua_get.lua}&quot; //加载脚本
evalsha {sha校验和} 1 redis world
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### Redis Api</span><br></pre></td></tr></table></figure>
</code></pre><p>redis.call(“set”,”hello”,”world”)<br>redis.call(“get”,”hello”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.4.3.案例</span><br><span class="line">Lua脚本在redis中提供的好处:</span><br><span class="line">1. Lua脚本原子执行</span><br><span class="line">2. 定制命令</span><br><span class="line">3. 可以将多条命令打包，节省网络开支</span><br></pre></td></tr></table></figure></p>
<p>— lrange_and_incr.lua<br>local tables mylist=redis.call(“lrange”,KEYS[1],0,-1)<br>local int count=0<br>for index,value in ipairs(mylist)<br>do<br>    redis.call(“incr”,key)<br>    count++<br>end<br>return count</p>
<p>redis-cli –eval lrange_and_incr.lua hot:user:list<br>(integer) 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.4.4.Redis管理Lua脚本</span><br><span class="line">1. script load</span><br></pre></td></tr></table></figure></p>
<pre><code>script load script
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. script exists</span><br></pre></td></tr></table></figure>

script exists {sha1}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3. script flush 清理Redis内存以及加载的Lua脚本</span><br><span class="line"></span><br><span class="line">4. script kill 杀死当前执行的Lua脚本</span><br><span class="line"></span><br><span class="line">## 3.5.Bitmaps</span><br><span class="line"></span><br><span class="line">Bitmaps给予了开发者操作位的能力，可以简单理解为以位为单位的一个数组，数组每一项只能为0和1</span><br><span class="line"></span><br><span class="line">1. 设置值</span><br></pre></td></tr></table></figure>

setbit key offset value
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 获取值</span><br></pre></td></tr></table></figure>

getbit key offset
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 获取指定范围值为1的个数</span><br></pre></td></tr></table></figure>

bitcount key [start] [end]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. BitMaps间的运算</span><br></pre></td></tr></table></figure>

bitop op destkey key [key ...] //op:and or not xor 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***实际案例***</span><br></pre></td></tr></table></figure>

//计算出两天都访问过网站的用户数量
bit op and unique:users:and:{date1_date2} unique:users:and:{date1} unique:users:and:{date2}
bitcount unique:users:and:{date1_datet2}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 计算BitMaps中第一个值为targetBit的偏移量</span><br></pre></td></tr></table></figure>

bitpos key targetBit [start] [end]

bitops unique:users:{date} 1 //计算某一天访问网站的最小用户id(偏移量标识用户id,0和1表示是否登录)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.7.发布订阅</span><br><span class="line"></span><br><span class="line">1. 发布消息</span><br></pre></td></tr></table></figure>

publish channel message

publish channel:sports &quot;XXXXXX&quot;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 订阅消息</span><br></pre></td></tr></table></figure>

subscribe channel [channel ...]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 取消订阅</span><br></pre></td></tr></table></figure>

ubsubscribe [channel [channel ...]]
punsubscribe [channel [channel ...]] //按照模式匹配取消订阅频道
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 查看订阅</span><br></pre></td></tr></table></figure>

pubsub channels [pattern] //查看活跃的频道，也就是当前频道至少有一个订阅者
pubsub numsub [channel ...] //查看频道订阅数
pubsub numpat //查看模式订阅数
```
</code></pre><p><strong><em>发布订阅模式用于进行服务的解耦，比如某个数据发生了变化能及时的反馈给订阅该频道(该时间)的订阅者，然后做出对于响应</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/18/redis-note-ch3/" data-id="ck0p948um0003bwv45in9kjug" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis-cache/">redis cache</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis-note-ch2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/18/redis-note-ch2/" class="article-date">
  <time datetime="2019-09-18T07:55:34.000Z" itemprop="datePublished">2019-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/18/redis-note-ch2/">《Redis开发与运维》第二章笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第二章-API的理解与使用"><a href="#第二章-API的理解与使用" class="headerlink" title="第二章 API的理解与使用"></a>第二章 API的理解与使用</h1><h2 id="2-1-1-全局命令"><a href="#2-1-1-全局命令" class="headerlink" title="2.1.1 全局命令"></a>2.1.1 全局命令</h2><p>1.查看所有键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure></p>
<p>2.键的总数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure></p>
<p>3.检查键是否存在(键存在返回0，不存在则返回1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exist key</span><br></pre></td></tr></table></figure></p>
<p>4.删除键(返回结果为删除的键的数量，若删除不存在的键返回0,且可以删除多个键)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure></p>
<p>5.键过期(默认过期时间以秒为单位)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br></pre></td></tr></table></figure></p>
<p>6.ttl命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure></p>
<p>ttl的返回值有：</p>
<ul>
<li>大于0:键剩余的过期时间</li>
<li>-1:键没有设置过期时间</li>
<li>-2:键不存在</li>
</ul>
<p>7.键的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-redis的数据类型"><a href="#2-2-redis的数据类型" class="headerlink" title="2.2.redis的数据类型"></a>2.2.redis的数据类型</h2><p>redis的数据类型有:</p>
<ul>
<li>字符串 string</li>
<li>哈希 hash</li>
<li>列表 list</li>
<li>集合 set</li>
<li>有序集合 zset</li>
</ul>
<p>下面分别介绍这些数据结构的使用</p>
<h3 id="2-2-1-字符串"><a href="#2-2-1-字符串" class="headerlink" title="2.2.1 字符串"></a>2.2.1 字符串</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>1.设置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure></p>
<p>set命令的选项</p>
<ul>
<li>ex seconds:为键设置过期时间，等价于set key val,expire key seconds</li>
<li>nx:(添加操作)键不存在时才能设置成功，常用于实现简单的分布式锁</li>
<li>xx:键存在的时候才能设置成功，用于更新操作</li>
</ul>
<p>2.获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></p>
<p>当键对应的值存在时候返回值，不存在时返回nil</p>
<p>3.批量设置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key val [key val ...]</span><br></pre></td></tr></table></figure></p>
<p>4.批量获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ...]</span><br></pre></td></tr></table></figure></p>
<p>获取的值会按照顺序打印出来</p>
<p><strong>批处理操作的优势</strong></p>
<p>批处理操作或减少网络通信的消耗，能提高redis的响应能力</p>
<ul>
<li><p>n次get操作:n次网络时间+n次操作时间</p>
</li>
<li><p>1次mget操作:1次网络时间+n次操作时间</p>
</li>
</ul>
<p>5.计数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure></p>
<p><strong>incr的返回值:</strong></p>
<ul>
<li>值不为整数，返回错误</li>
<li>值是整数，返回自增后的结果</li>
<li>键不存在，则从0开始自增，返回1</li>
</ul>
<h4 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h4><p>1.字符串长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure></p>
<p>2.设置并返回原值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset key val</span><br></pre></td></tr></table></figure></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1.缓存功能</p>
<p>通过使用缓存降低数据库读写压力，提升系统响应能力，防止因为过多的请求导致数据库崩溃</p>
<p><strong>1).基本思路:</strong></p>
<p>在从数据库查出数据后，将数据序列化后放入redis(需设置过期时间)中，下次再获取数据从redis中取出来再反序列化即可,<br>减少了对数据库的访问压力</p>
<p><img src="/source/images/redis_note_img/cache.png" alt></p>
<p><strong>2).设计合理的键名</strong></p>
<p>“业务名:对象名:id:[属性]”</p>
<p>2.计数功能</p>
<p>例如可以用来作为视频播放量的计数器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr video:playCount:&#123;id&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.共享session</p>
<p>在分布式服务中，若使用传统的session方案(例如Tomcat)，会造成用户登陆后刷新又需要重新登录，因为分布式架构中,<br>负载均衡会将用户的请求均衡的不同的服务器上，而传统的session方案会将session存放在本地服务器中，因此此时session<br>会失效</p>
<p><strong>redis解决思路:</strong></p>
<p>多个服务器都将session放在redis中，这样就可以解决上述问题</p>
<p>4.限速</p>
<p>主要用于那些限制用户操作频率的功能(比如获取验证码的频率),下面列出伪代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">phoneNumber=&quot;xxxxx&quot;;</span><br><span class="line">key=&quot;shortMsg:limit:&quot;+phoneNumber;</span><br><span class="line">isExists=redis.set(key,1,&quot;EX 60&quot;,&quot;NX&quot;);</span><br><span class="line">if(isExists!=null||redis.incr(key)&lt;=5)</span><br><span class="line">    //通过</span><br><span class="line">else</span><br><span class="line">    //限速</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-2-哈希"><a href="#2-2-2-哈希" class="headerlink" title="2.2.2 哈希"></a>2.2.2 哈希</h3><p>哈希是一个键值对数据类型，类似Java中的Map</p>
<h4 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h4><p>1.设置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line">hset user:1 name xiaoming</span><br></pre></td></tr></table></figure></p>
<p>设置成功后返回1，失败返回0。同时也有hsetnx，但是作用域在field而不是key</p>
<p>2.获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line"></span><br><span class="line">hget user:1 name</span><br></pre></td></tr></table></figure></p>
<p>获取成功后返回对应的值，失败则返回nil</p>
<p>3.删除field</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field ...]</span><br></pre></td></tr></table></figure>
<p>4.计算field个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure>
<p>5.批量操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field ...]</span><br><span class="line">hmset key field value [field value...]</span><br></pre></td></tr></table></figure>
<p>6.判断field是否存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure>
<p>7.获取所有的field</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br></pre></td></tr></table></figure>
<p>8.获取所有的value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br></pre></td></tr></table></figure>
<p>9.获取所有的field-value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure>
<p><strong>使用注意:在元素较多的时候hegetall有可能会阻塞redis,如果一定要获取全部的field-value可以使用hscan</strong></p>
<p>10.hincrby hincrbyfloat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field</span><br><span class="line">hincrbyfloat key field</span><br></pre></td></tr></table></figure>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>用hash表保存用户信息，用类似关系型数据库的方式.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name xiaoming</span><br><span class="line">set user:1:age 18</span><br><span class="line">set user:1:city beijing</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-3-列表"><a href="#2-2-3-列表" class="headerlink" title="2.2.3 列表"></a>2.2.3 列表</h3><p>列表类似JavaScript中的数组，可以在数组两端进行插入和弹出,可以充当栈和队列的角色</p>
<p><strong>列表的特点:</strong></p>
<ul>
<li>有序:能够根据索引找到一个值</li>
<li>可重复</li>
</ul>
<h4 id="基本命令-2"><a href="#基本命令-2" class="headerlink" title="基本命令"></a>基本命令</h4><p>1.添加操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value ...] //右边插入元素</span><br><span class="line">lpush key value [value ...] //左边插入元素</span><br></pre></td></tr></table></figure></p>
<p>2.查找操作</p>
<ul>
<li><p>lrange(redis获取出来的元素包括end)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end</span><br></pre></td></tr></table></figure>
</li>
<li><p>lindex</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex key index</span><br></pre></td></tr></table></figure>
</li>
<li><p>llen(获取列表长度)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3.删除操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lpop key //左侧弹出元素</span><br><span class="line">rpop key //右侧弹出元素</span><br><span class="line">lrem key count value //找出等于value的元素删除，count&gt;0，从左到右删除最多count个元素,count&lt;0,从右到左删除，count=0删除所有</span><br><span class="line"></span><br><span class="line">ltrim key start end //按照索引范围修剪列表</span><br></pre></td></tr></table></figure>
<p>4.阻塞操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ...] timeout</span><br><span class="line">brpop key [key ...] timeout</span><br></pre></td></tr></table></figure></p>
<ul>
<li>timeout为阻塞时间，timeout大于0时，客户端会等到超时时间过后再返回，<br>若timeout为0时，客户端会一直阻塞下去，知道往列表中添加了元素</li>
<li>如果列表不为空，客户端会立即返回</li>
</ul>
<p><strong>注意点:</strong></p>
<p>如果阻塞弹出操作有多个键，会从左到右遍历键，一旦有一个键能弹出元素，客户端立即返回</p>
<p>如果多个客户端对同一个键执行阻塞弹出操作，那么最先执行命令的客户端可以获取弹出的值(优先级)</p>
<p><strong>分析:这是一个典型的阻塞队列实现,根据此特性redis可以作为简单的消息队列</strong></p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>1.消息队列</p>
<p>通过lpush和brpop即可实现阻塞队列,生产者通过lpush从左侧插入元素，消费者阻塞的从列表右侧获取元素</p>
<p>2.文章列表</p>
<p>1)文章使用哈希结构，保存文章的属性，例如作者和创建时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset article:1 title xx timestamp xx author xx</span><br></pre></td></tr></table></figure></p>
<p>2)用户的文章列表用列表来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush user:1:articles article:1 article:2</span><br></pre></td></tr></table></figure></p>
<p>3.实现多种数据结构功能</p>
<ul>
<li>lpush+lpop=Stack</li>
<li>lpush+rpop=Queue</li>
<li>lpush+brpop=Message Queue</li>
</ul>
<h3 id="2-2-4-集合"><a href="#2-2-4-集合" class="headerlink" title="2.2.4 集合"></a>2.2.4 集合</h3><h4 id="基本命令-3"><a href="#基本命令-3" class="headerlink" title="基本命令"></a>基本命令</h4><p>集合和列表不同点在于集合不允许有重复的元素(类似Java的Set),而且集合无序，无法通过索引获取元素<br>同时集合还可以进行并交差集计算</p>
<p>1.添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element ...]</span><br></pre></td></tr></table></figure></p>
<p>2.删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key element [element ...]</span><br></pre></td></tr></table></figure></p>
<p>3.计算元素个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure></p>
<p>4.判断元素是否在几何中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key element</span><br></pre></td></tr></table></figure></p>
<p>5.随机从集合中返回指定个数的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure></p>
<p>6.从集合中随机弹出元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key</span><br></pre></td></tr></table></figure></p>
<p>7.获取所有元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure>
<p><strong>sememebers和hegetall一样有阻塞redis的风险，建议使用sscan</strong></p>
<p>8.集合间操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key ...] //交集</span><br><span class="line">sunion key [key ...] //并集</span><br><span class="line">sdiff key [key ...] //差集</span><br><span class="line">sinterstore destination key [key ...] //交集结果保存</span><br><span class="line">sunionstore ...</span><br><span class="line">sdiffstore ...</span><br></pre></td></tr></table></figure></p>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>标签功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag3 //给用户添加标签</span><br><span class="line">sadd user:2:tags tag1 tag2 tag4</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">sadd tag:1 user:1 user:2 //给标签添加用户</span><br><span class="line">sadd tag:2 user:1 user:2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">srem user:1 tag:1 //删除用户的标签</span><br><span class="line"></span><br><span class="line">srem tag:1 user:1 //删除标签的用户</span><br><span class="line"></span><br><span class="line">sinter user:1 user:2 //计算用户共同感兴趣的标签</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-5-有序集合"><a href="#2-2-5-有序集合" class="headerlink" title="2.2.5 有序集合"></a>2.2.5 有序集合</h3><p>有序集合保留了集合没有重复元素的特性的同时又做到了有序性,<br>有序性是通过score来作为排序的依据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">伪代码:</span><br><span class="line">user:ranking [</span><br><span class="line">    &#123;score:1,member:&quot;XX&quot;&#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h4 id="基本命令-4"><a href="#基本命令-4" class="headerlink" title="基本命令"></a>基本命令</h4><p>1.添加成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member [score member ...]</span><br></pre></td></tr></table></figure></p>
<p><strong>zadd的参数:</strong></p>
<ul>
<li>nx: member不存在才能添加，用于添加操作</li>
<li>xx: member存在才能添加，用于更新</li>
<li>ch: 返回此次操作后，score和member发生变化的个数</li>
<li>incr: 对score进行增加</li>
</ul>
<ol start="2">
<li>计算成员个数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.计算某个成员的分数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br></pre></td></tr></table></figure></p>
<p>4.计算成员的排名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrank key memeber</span><br></pre></td></tr></table></figure></p>
<p>5.删除成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure></p>
<p>6.增加成员分数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></p>
<p>7.返回指定排名范围内的成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key start end [withscores]</span><br><span class="line">zrevrange key start end [withscores]</span><br></pre></td></tr></table></figure></p>
<p>8.返回指定分数范围内的成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [limit offset count]</span><br><span class="line">zrevrangebyscore key min max [limit offset count]</span><br></pre></td></tr></table></figure></p>
<p>9.返回指定分数范围成员个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></p>
<p>10.删除指定排名范围内元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure></p>
<p>11.删除指定分数范围内元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></p>
<h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>类似游戏排行榜，学生成绩排名都可以使用zset来实现<br>赞数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd user:ranking:&#123;timestamp&#125; mike 3</span><br><span class="line">zincrby user:ranking:&#123;timestamp&#125; mike 1 //点赞</span><br><span class="line">zrem user:ranking:&#123;timestamp&#125; mike //删除用户在榜单中对应赞数</span><br><span class="line">srevrangebyrank user:ranking:&#123;timestamp&#125; 0 9 //展示获取赞数最多的十个用户</span><br><span class="line"></span><br><span class="line">//展示用户信息和用户分数</span><br><span class="line">hegetall user:info:tom </span><br><span class="line">zscore user:ranking:&#123;tiemstamp&#125; tom</span><br><span class="line">zrank user:ranking:&#123;timestamp&#125; tom</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-键管理"><a href="#2-3-键管理" class="headerlink" title="2.3 键管理"></a>2.3 键管理</h3><h4 id="2-3-1-单个键管理"><a href="#2-3-1-单个键管理" class="headerlink" title="2.3.1 单个键管理"></a>2.3.1 单个键管理</h4><p>1.键重命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br></pre></td></tr></table></figure></p>
<p>2.随机返回一个key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-2-遍历键"><a href="#2-3-2-遍历键" class="headerlink" title="2.3.2 遍历键"></a>2.3.2 遍历键</h4><p>1.全量遍历键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure></p>
<p>pattern的通配符:</p>
<ul>
<li>*代表任意字符</li>
<li>[]代表匹配部分字符</li>
</ul>
<p>2.渐进式遍历<br>scan命令可以解决keys可能造成阻塞的问题(当元素数量较大时)<br>scan可以理解为每次只扫描一部分数据，扫描完当前数据后再移动指针扫描后续数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor [match pattern] [count number] //count number表示每次遍历的个数，默认为10</span><br></pre></td></tr></table></figure>
<p><strong>scan的返回值有两项，第一项为下一次scan需要的cursor(当返回的值为0时，说明所有键都遍历完了)，第二项为返回的键</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/18/redis-note-ch2/" data-id="ck0p948ue0001bwv4vtpeg6b2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis-cache/">redis cache</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-alogrithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/05/alogrithm/" class="article-date">
  <time datetime="2019-05-05T05:03:23.000Z" itemprop="datePublished">2019-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/05/alogrithm/">alogrithm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="《算法-第四版》第二章排序笔记"><a href="#《算法-第四版》第二章排序笔记" class="headerlink" title="《算法 第四版》第二章排序笔记"></a>《算法 第四版》第二章排序笔记</h1><p>书中讲到的排序算法主要分为以下几种:</p>
<ul>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序就是在数组中找到最小的元素,然后将它和数组第一个元素交换(默认正序,若第一个元素就是最小的元素,那就和自己交换).<br>然后在剩下的元素中找到最小的元素重复上述操作,这里需要注意数组边界防止越界</p>
<h3 id="选择排序的特点"><a href="#选择排序的特点" class="headerlink" title="选择排序的特点"></a>选择排序的特点</h3><ul>
<li>运行时间和输入数据无关：不管输入的数组是有序或无序的,都会进行比较找出最小元素,所以会比较低效</li>
<li>数据移动最少:交换次数与数组大小为线性关系，会进行N次交换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void sort(Comparable[] a) &#123;</span><br><span class="line">        int len = a.length;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int min = i;</span><br><span class="line"></span><br><span class="line">            for (int j = i + 1; j &lt; len; j++)</span><br><span class="line">                //标记比已知最小元素还小的元素的索引</span><br><span class="line">                if (SortTemplate.less(a[j], a[min])) min = j;</span><br><span class="line">            //和现在的最小元素交换位置</span><br><span class="line">            SortTemplate.exchange(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //以动态的眼光来看要排序的数组实际会被拆分成两个数组，</span><br><span class="line">    //已被排序的数组和未被排序的数组.代码运行会经过这样的</span><br><span class="line">    //过程,0-&gt;len找出最小的放在0,1-&gt;len找出最小的放在1,</span><br><span class="line">    //...,len-1-&gt;len找出最小的放在len-1</span><br></pre></td></tr></table></figure>
<h3 id="对选择排序的分析"><a href="#对选择排序的分析" class="headerlink" title="对选择排序的分析"></a>对选择排序的分析</h3><p>便于理解，代码短</p>
<p>但是过于死板，即使数组已经有序仍然会执行.效率较差,算法时间复杂度为n2</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序跟打斗地主很像,在整理牌的时候,会根据大小不断调换牌的位置.当你插入一张牌的时候，他左边的牌应该是有序的.同理,在插入排序中，从索引1开始，与自己左边的元素做比较，若小于其中的元素则交换，但并不代表这个元素之后就不会再移动了，他后面的元素可能还会移动他.移动到最后一个元素后数组就有序了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void sort(Comparable[] a) &#123;</span><br><span class="line">        int len = a.length;</span><br><span class="line"></span><br><span class="line">        //和左边的元素进行比较所以从索引1开始</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = i; j &gt;0&amp;&amp; SortTemplate.less(a[j],a[j-1]); j--) &#123;</span><br><span class="line">                SortTemplate.exchange(a, j, j - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对插入排序的分析"><a href="#对插入排序的分析" class="headerlink" title="对插入排序的分析"></a>对插入排序的分析</h3><p>适合大型且基本有序的数组，代码简单易于理解，而且非常适合元素较少的排序</p>
<p>但对于大型的无序数组还是不够高效</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序基于插入排序，插入排序的缺点就是交换元素非常慢，只能相邻的元素进行交换。希尔排序以间隔将数组分为若干个数组，这些数组有序后再进行插入排序就非常高效。具体步骤可能如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 7 3 1 5 6 8 2 3 4 </span><br><span class="line">2     1     8     4</span><br><span class="line">  7     5     2</span><br><span class="line">    3     6     4</span><br></pre></td></tr></table></figure></p>
<p>间隔会不断变化，当间隔变成1时此时就完全是插入排序了.希尔排序通过间隔拆分成若干个数组不断进行交换位置，并且间隔不断减小，最后再进行插入排序时就很方便</p>
<p>至于如何选择合适的间隔，这是一个数学问题，不在着重学习范围内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void sort(Comparable[] a) &#123;</span><br><span class="line">    int len=a.length;</span><br><span class="line">    int h=1;</span><br><span class="line">    while (h&lt;len/3) h = 3 * h + 1;</span><br><span class="line"></span><br><span class="line">    while (h&gt;=1)&#123;</span><br><span class="line">        for (int i = h; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = i; j &gt;=h&amp;&amp;SortTemplate.less(a[j],a[j-h]) ; j-=h) &#123;</span><br><span class="line">                SortTemplate.exchange(a, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的核心思想是分而治之,从字面上可以简单的理解为递归的合并.将两个有序的数组合并到一个数组，并不断重复，直到整个数组有序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//原地归并，只需要一个数组，而不是每次归并都创建一个新数组</span><br><span class="line">    private Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    public void merge(Comparable[] a,int low,int mid,int high)&#123;</span><br><span class="line">            //i:左边元素,j:右边元素</span><br><span class="line">            int i=low,j=mid+1;</span><br><span class="line">            </span><br><span class="line">            //将元素复制到辅助数组中</span><br><span class="line">            for (int k = low; k &lt;=high ; k++)</span><br><span class="line">                aux[k] = a[k];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (int k = low; k &lt;=high ; k++)</span><br><span class="line">                if (i&gt;mid)a[k]=aux[j++];//左边元素用尽,取右边元素</span><br><span class="line">                else if (j&gt;high)a[k]=aux[i++];//右边元素用尽,取左边元素</span><br><span class="line">                else if (SortTemplate.less(a[j],a[i]))a[k]=aux[j++];//右边元素小于左边元素</span><br><span class="line">                else a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    public void sort(Comparable[] a) &#123;</span><br><span class="line">        aux = new Comparable[a.length];</span><br><span class="line">        sort(a,0,a.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void sort(Comparable[] a,int low,int high)&#123;</span><br><span class="line">        //分而治之,将数组拆成小的数组排序再归并</span><br><span class="line">        if (high&lt;=low)return;</span><br><span class="line">        int mid = low + (high - low) / 2;</span><br><span class="line">        //左边排序</span><br><span class="line">        sort(a,0,mid);</span><br><span class="line">        //右边排序</span><br><span class="line">        sort(a,mid+1,high);</span><br><span class="line">        //将两个已经排序好的归并</span><br><span class="line">        merge(a,low,mid,high);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过下面的图将获取最直观的感受<br><img src="/images/sort/sort.png" alt></p>
<p><img src="/images/sort/merge.png" alt></p>
<p><img src="/images/sort/detail.png" alt></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序同归并排序一样用到了分治的思想,不过快排是将一个数组分成两个数组，让他们单独进行排序,当子数组有序了整个数组也就有序了,用代码和图解释起来更直白<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void sort(Comparable[] a) &#123;</span><br><span class="line">    sort(a,0,a.length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int partition(Comparable[] a,int low,int high)&#123;</span><br><span class="line">    int i = low, j = high - 1;</span><br><span class="line">    //默认取最低位元素为基准</span><br><span class="line">    Comparable v = a[low];</span><br><span class="line"></span><br><span class="line">    while (true)&#123;</span><br><span class="line">        while (SortTemplate.less(a[++i],v))</span><br><span class="line">            if (i==high) break;</span><br><span class="line">        while (SortTemplate.less(v,a[++j]))</span><br><span class="line">            if (j==low) break;</span><br><span class="line">        if (i&gt;=j)break;</span><br><span class="line">        SortTemplate.exchange(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    SortTemplate.exchange(a, low, i);</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sort(Comparable[] a,int low,int high)&#123;</span><br><span class="line">    if (high&lt;=low) return;</span><br><span class="line"></span><br><span class="line">    int j = partition(a, low, high);</span><br><span class="line"></span><br><span class="line">    sort(a,low,j-1);</span><br><span class="line">    sort(a,j+1,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/sort/quickSort.png" alt></p>
<p><img src="/images/sort/partition.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/05/alogrithm/" data-id="ck0p948u90000bwv49mcmbjzw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/alogrithm-sort/">alogrithm sort</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/alogrithm-sort/">alogrithm sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis-cache/">redis cache</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/alogrithm-sort/" style="font-size: 10px;">alogrithm sort</a> <a href="/tags/redis-cache/" style="font-size: 20px;">redis cache</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/18/redis-note-ch3/">《Redis开发与运维》第三章笔记</a>
          </li>
        
          <li>
            <a href="/2019/09/18/redis-note-ch2/">《Redis开发与运维》第二章笔记</a>
          </li>
        
          <li>
            <a href="/2019/05/05/alogrithm/">alogrithm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Idealv<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>