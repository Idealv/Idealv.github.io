<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>《Redis开发与运维》第二章笔记 | Idealv的杂七杂八</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第二章 API的理解与使用2.1.1 全局命令1.查看所有键1keys * 2.键的总数1dbsize 3.检查键是否存在(键存在返回0，不存在则返回1)1exist key 4.删除键(返回结果为删除的键的数量，若删除不存在的键返回0,且可以删除多个键)1del key 5.键过期(默认过期时间以秒为单位)1expire key seconds 6.ttl命令1ttl key ttl的返回值有：">
<meta name="keywords" content="redis cache">
<meta property="og:type" content="article">
<meta property="og:title" content="《Redis开发与运维》第二章笔记">
<meta property="og:url" content="http://yoursite.com/2019/09/18/redis-note-ch2/index.html">
<meta property="og:site_name" content="Idealv的杂七杂八">
<meta property="og:description" content="第二章 API的理解与使用2.1.1 全局命令1.查看所有键1keys * 2.键的总数1dbsize 3.检查键是否存在(键存在返回0，不存在则返回1)1exist key 4.删除键(返回结果为删除的键的数量，若删除不存在的键返回0,且可以删除多个键)1del key 5.键过期(默认过期时间以秒为单位)1expire key seconds 6.ttl命令1ttl key ttl的返回值有：">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/source/images/redis_note_img/cache.png">
<meta property="og:updated_time" content="2019-09-18T10:42:01.326Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Redis开发与运维》第二章笔记">
<meta name="twitter:description" content="第二章 API的理解与使用2.1.1 全局命令1.查看所有键1keys * 2.键的总数1dbsize 3.检查键是否存在(键存在返回0，不存在则返回1)1exist key 4.删除键(返回结果为删除的键的数量，若删除不存在的键返回0,且可以删除多个键)1del key 5.键过期(默认过期时间以秒为单位)1expire key seconds 6.ttl命令1ttl key ttl的返回值有：">
<meta name="twitter:image" content="http://yoursite.com/source/images/redis_note_img/cache.png">
  
    <link rel="alternate" href="/atom.xml" title="Idealv的杂七杂八" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Idealv的杂七杂八</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-redis-note-ch2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/18/redis-note-ch2/" class="article-date">
  <time datetime="2019-09-18T07:55:34.000Z" itemprop="datePublished">2019-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《Redis开发与运维》第二章笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第二章-API的理解与使用"><a href="#第二章-API的理解与使用" class="headerlink" title="第二章 API的理解与使用"></a>第二章 API的理解与使用</h1><h2 id="2-1-1-全局命令"><a href="#2-1-1-全局命令" class="headerlink" title="2.1.1 全局命令"></a>2.1.1 全局命令</h2><p>1.查看所有键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure></p>
<p>2.键的总数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure></p>
<p>3.检查键是否存在(键存在返回0，不存在则返回1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exist key</span><br></pre></td></tr></table></figure></p>
<p>4.删除键(返回结果为删除的键的数量，若删除不存在的键返回0,且可以删除多个键)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure></p>
<p>5.键过期(默认过期时间以秒为单位)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br></pre></td></tr></table></figure></p>
<p>6.ttl命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure></p>
<p>ttl的返回值有：</p>
<ul>
<li>大于0:键剩余的过期时间</li>
<li>-1:键没有设置过期时间</li>
<li>-2:键不存在</li>
</ul>
<p>7.键的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-redis的数据类型"><a href="#2-2-redis的数据类型" class="headerlink" title="2.2.redis的数据类型"></a>2.2.redis的数据类型</h2><p>redis的数据类型有:</p>
<ul>
<li>字符串 string</li>
<li>哈希 hash</li>
<li>列表 list</li>
<li>集合 set</li>
<li>有序集合 zset</li>
</ul>
<p>下面分别介绍这些数据结构的使用</p>
<h3 id="2-2-1-字符串"><a href="#2-2-1-字符串" class="headerlink" title="2.2.1 字符串"></a>2.2.1 字符串</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>1.设置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure></p>
<p>set命令的选项</p>
<ul>
<li>ex seconds:为键设置过期时间，等价于set key val,expire key seconds</li>
<li>nx:(添加操作)键不存在时才能设置成功，常用于实现简单的分布式锁</li>
<li>xx:键存在的时候才能设置成功，用于更新操作</li>
</ul>
<p>2.获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure></p>
<p>当键对应的值存在时候返回值，不存在时返回nil</p>
<p>3.批量设置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key val [key val ...]</span><br></pre></td></tr></table></figure></p>
<p>4.批量获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ...]</span><br></pre></td></tr></table></figure></p>
<p>获取的值会按照顺序打印出来</p>
<p><strong>批处理操作的优势</strong></p>
<p>批处理操作或减少网络通信的消耗，能提高redis的响应能力</p>
<ul>
<li><p>n次get操作:n次网络时间+n次操作时间</p>
</li>
<li><p>1次mget操作:1次网络时间+n次操作时间</p>
</li>
</ul>
<p>5.计数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure></p>
<p><strong>incr的返回值:</strong></p>
<ul>
<li>值不为整数，返回错误</li>
<li>值是整数，返回自增后的结果</li>
<li>键不存在，则从0开始自增，返回1</li>
</ul>
<h4 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h4><p>1.字符串长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure></p>
<p>2.设置并返回原值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset key val</span><br></pre></td></tr></table></figure></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1.缓存功能</p>
<p>通过使用缓存降低数据库读写压力，提升系统响应能力，防止因为过多的请求导致数据库崩溃</p>
<p><strong>1).基本思路:</strong></p>
<p>在从数据库查出数据后，将数据序列化后放入redis(需设置过期时间)中，下次再获取数据从redis中取出来再反序列化即可,<br>减少了对数据库的访问压力</p>
<p><img src="/source/images/redis_note_img/cache.png" alt></p>
<p><strong>2).设计合理的键名</strong></p>
<p>“业务名:对象名:id:[属性]”</p>
<p>2.计数功能</p>
<p>例如可以用来作为视频播放量的计数器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr video:playCount:&#123;id&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.共享session</p>
<p>在分布式服务中，若使用传统的session方案(例如Tomcat)，会造成用户登陆后刷新又需要重新登录，因为分布式架构中,<br>负载均衡会将用户的请求均衡的不同的服务器上，而传统的session方案会将session存放在本地服务器中，因此此时session<br>会失效</p>
<p><strong>redis解决思路:</strong></p>
<p>多个服务器都将session放在redis中，这样就可以解决上述问题</p>
<p>4.限速</p>
<p>主要用于那些限制用户操作频率的功能(比如获取验证码的频率),下面列出伪代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">phoneNumber=&quot;xxxxx&quot;;</span><br><span class="line">key=&quot;shortMsg:limit:&quot;+phoneNumber;</span><br><span class="line">isExists=redis.set(key,1,&quot;EX 60&quot;,&quot;NX&quot;);</span><br><span class="line">if(isExists!=null||redis.incr(key)&lt;=5)</span><br><span class="line">    //通过</span><br><span class="line">else</span><br><span class="line">    //限速</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-2-哈希"><a href="#2-2-2-哈希" class="headerlink" title="2.2.2 哈希"></a>2.2.2 哈希</h3><p>哈希是一个键值对数据类型，类似Java中的Map</p>
<h4 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h4><p>1.设置值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line">hset user:1 name xiaoming</span><br></pre></td></tr></table></figure></p>
<p>设置成功后返回1，失败返回0。同时也有hsetnx，但是作用域在field而不是key</p>
<p>2.获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line"></span><br><span class="line">hget user:1 name</span><br></pre></td></tr></table></figure></p>
<p>获取成功后返回对应的值，失败则返回nil</p>
<p>3.删除field</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field ...]</span><br></pre></td></tr></table></figure>
<p>4.计算field个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure>
<p>5.批量操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field ...]</span><br><span class="line">hmset key field value [field value...]</span><br></pre></td></tr></table></figure>
<p>6.判断field是否存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure>
<p>7.获取所有的field</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br></pre></td></tr></table></figure>
<p>8.获取所有的value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br></pre></td></tr></table></figure>
<p>9.获取所有的field-value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure>
<p><strong>使用注意:在元素较多的时候hegetall有可能会阻塞redis,如果一定要获取全部的field-value可以使用hscan</strong></p>
<p>10.hincrby hincrbyfloat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field</span><br><span class="line">hincrbyfloat key field</span><br></pre></td></tr></table></figure>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>用hash表保存用户信息，用类似关系型数据库的方式.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name xiaoming</span><br><span class="line">set user:1:age 18</span><br><span class="line">set user:1:city beijing</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-3-列表"><a href="#2-2-3-列表" class="headerlink" title="2.2.3 列表"></a>2.2.3 列表</h3><p>列表类似JavaScript中的数组，可以在数组两端进行插入和弹出,可以充当栈和队列的角色</p>
<p><strong>列表的特点:</strong></p>
<ul>
<li>有序:能够根据索引找到一个值</li>
<li>可重复</li>
</ul>
<h4 id="基本命令-2"><a href="#基本命令-2" class="headerlink" title="基本命令"></a>基本命令</h4><p>1.添加操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value ...] //右边插入元素</span><br><span class="line">lpush key value [value ...] //左边插入元素</span><br></pre></td></tr></table></figure></p>
<p>2.查找操作</p>
<ul>
<li><p>lrange(redis获取出来的元素包括end)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end</span><br></pre></td></tr></table></figure>
</li>
<li><p>lindex</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex key index</span><br></pre></td></tr></table></figure>
</li>
<li><p>llen(获取列表长度)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3.删除操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lpop key //左侧弹出元素</span><br><span class="line">rpop key //右侧弹出元素</span><br><span class="line">lrem key count value //找出等于value的元素删除，count&gt;0，从左到右删除最多count个元素,count&lt;0,从右到左删除，count=0删除所有</span><br><span class="line"></span><br><span class="line">ltrim key start end //按照索引范围修剪列表</span><br></pre></td></tr></table></figure>
<p>4.阻塞操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ...] timeout</span><br><span class="line">brpop key [key ...] timeout</span><br></pre></td></tr></table></figure></p>
<ul>
<li>timeout为阻塞时间，timeout大于0时，客户端会等到超时时间过后再返回，<br>若timeout为0时，客户端会一直阻塞下去，知道往列表中添加了元素</li>
<li>如果列表不为空，客户端会立即返回</li>
</ul>
<p><strong>注意点:</strong></p>
<p>如果阻塞弹出操作有多个键，会从左到右遍历键，一旦有一个键能弹出元素，客户端立即返回</p>
<p>如果多个客户端对同一个键执行阻塞弹出操作，那么最先执行命令的客户端可以获取弹出的值(优先级)</p>
<p><strong>分析:这是一个典型的阻塞队列实现,根据此特性redis可以作为简单的消息队列</strong></p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>1.消息队列</p>
<p>通过lpush和brpop即可实现阻塞队列,生产者通过lpush从左侧插入元素，消费者阻塞的从列表右侧获取元素</p>
<p>2.文章列表</p>
<p>1)文章使用哈希结构，保存文章的属性，例如作者和创建时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset article:1 title xx timestamp xx author xx</span><br></pre></td></tr></table></figure></p>
<p>2)用户的文章列表用列表来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush user:1:articles article:1 article:2</span><br></pre></td></tr></table></figure></p>
<p>3.实现多种数据结构功能</p>
<ul>
<li>lpush+lpop=Stack</li>
<li>lpush+rpop=Queue</li>
<li>lpush+brpop=Message Queue</li>
</ul>
<h3 id="2-2-4-集合"><a href="#2-2-4-集合" class="headerlink" title="2.2.4 集合"></a>2.2.4 集合</h3><h4 id="基本命令-3"><a href="#基本命令-3" class="headerlink" title="基本命令"></a>基本命令</h4><p>集合和列表不同点在于集合不允许有重复的元素(类似Java的Set),而且集合无序，无法通过索引获取元素<br>同时集合还可以进行并交差集计算</p>
<p>1.添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element ...]</span><br></pre></td></tr></table></figure></p>
<p>2.删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key element [element ...]</span><br></pre></td></tr></table></figure></p>
<p>3.计算元素个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure></p>
<p>4.判断元素是否在几何中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key element</span><br></pre></td></tr></table></figure></p>
<p>5.随机从集合中返回指定个数的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure></p>
<p>6.从集合中随机弹出元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key</span><br></pre></td></tr></table></figure></p>
<p>7.获取所有元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure>
<p><strong>sememebers和hegetall一样有阻塞redis的风险，建议使用sscan</strong></p>
<p>8.集合间操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key ...] //交集</span><br><span class="line">sunion key [key ...] //并集</span><br><span class="line">sdiff key [key ...] //差集</span><br><span class="line">sinterstore destination key [key ...] //交集结果保存</span><br><span class="line">sunionstore ...</span><br><span class="line">sdiffstore ...</span><br></pre></td></tr></table></figure></p>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>标签功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag3 //给用户添加标签</span><br><span class="line">sadd user:2:tags tag1 tag2 tag4</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">sadd tag:1 user:1 user:2 //给标签添加用户</span><br><span class="line">sadd tag:2 user:1 user:2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">srem user:1 tag:1 //删除用户的标签</span><br><span class="line"></span><br><span class="line">srem tag:1 user:1 //删除标签的用户</span><br><span class="line"></span><br><span class="line">sinter user:1 user:2 //计算用户共同感兴趣的标签</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-5-有序集合"><a href="#2-2-5-有序集合" class="headerlink" title="2.2.5 有序集合"></a>2.2.5 有序集合</h3><p>有序集合保留了集合没有重复元素的特性的同时又做到了有序性,<br>有序性是通过score来作为排序的依据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">伪代码:</span><br><span class="line">user:ranking [</span><br><span class="line">    &#123;score:1,member:&quot;XX&quot;&#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h4 id="基本命令-4"><a href="#基本命令-4" class="headerlink" title="基本命令"></a>基本命令</h4><p>1.添加成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member [score member ...]</span><br></pre></td></tr></table></figure></p>
<p><strong>zadd的参数:</strong></p>
<ul>
<li>nx: member不存在才能添加，用于添加操作</li>
<li>xx: member存在才能添加，用于更新</li>
<li>ch: 返回此次操作后，score和member发生变化的个数</li>
<li>incr: 对score进行增加</li>
</ul>
<ol start="2">
<li>计算成员个数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.计算某个成员的分数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br></pre></td></tr></table></figure></p>
<p>4.计算成员的排名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrank key memeber</span><br></pre></td></tr></table></figure></p>
<p>5.删除成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure></p>
<p>6.增加成员分数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure></p>
<p>7.返回指定排名范围内的成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key start end [withscores]</span><br><span class="line">zrevrange key start end [withscores]</span><br></pre></td></tr></table></figure></p>
<p>8.返回指定分数范围内的成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [limit offset count]</span><br><span class="line">zrevrangebyscore key min max [limit offset count]</span><br></pre></td></tr></table></figure></p>
<p>9.返回指定分数范围成员个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure></p>
<p>10.删除指定排名范围内元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure></p>
<p>11.删除指定分数范围内元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure></p>
<h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>类似游戏排行榜，学生成绩排名都可以使用zset来实现<br>赞数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd user:ranking:&#123;timestamp&#125; mike 3</span><br><span class="line">zincrby user:ranking:&#123;timestamp&#125; mike 1 //点赞</span><br><span class="line">zrem user:ranking:&#123;timestamp&#125; mike //删除用户在榜单中对应赞数</span><br><span class="line">srevrangebyrank user:ranking:&#123;timestamp&#125; 0 9 //展示获取赞数最多的十个用户</span><br><span class="line"></span><br><span class="line">//展示用户信息和用户分数</span><br><span class="line">hegetall user:info:tom </span><br><span class="line">zscore user:ranking:&#123;tiemstamp&#125; tom</span><br><span class="line">zrank user:ranking:&#123;timestamp&#125; tom</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-键管理"><a href="#2-3-键管理" class="headerlink" title="2.3 键管理"></a>2.3 键管理</h3><h4 id="2-3-1-单个键管理"><a href="#2-3-1-单个键管理" class="headerlink" title="2.3.1 单个键管理"></a>2.3.1 单个键管理</h4><p>1.键重命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br></pre></td></tr></table></figure></p>
<p>2.随机返回一个key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-2-遍历键"><a href="#2-3-2-遍历键" class="headerlink" title="2.3.2 遍历键"></a>2.3.2 遍历键</h4><p>1.全量遍历键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure></p>
<p>pattern的通配符:</p>
<ul>
<li>*代表任意字符</li>
<li>[]代表匹配部分字符</li>
</ul>
<p>2.渐进式遍历<br>scan命令可以解决keys可能造成阻塞的问题(当元素数量较大时)<br>scan可以理解为每次只扫描一部分数据，扫描完当前数据后再移动指针扫描后续数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor [match pattern] [count number] //count number表示每次遍历的个数，默认为10</span><br></pre></td></tr></table></figure>
<p><strong>scan的返回值有两项，第一项为下一次scan需要的cursor(当返回的值为0时，说明所有键都遍历完了)，第二项为返回的键</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/18/redis-note-ch2/" data-id="ck0qj2y250003egv4v06m5lpo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis-cache/">redis cache</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/18/redis-note-ch3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          《Redis开发与运维》第三章笔记
        
      </div>
    </a>
  
  
    <a href="/2019/05/05/alogrithm/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">alogrithm</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/alogrithm-sort/">alogrithm sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis-cache/">redis cache</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/alogrithm-sort/" style="font-size: 10px;">alogrithm sort</a> <a href="/tags/redis-cache/" style="font-size: 20px;">redis cache</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/18/redis-note-ch3/">《Redis开发与运维》第三章笔记</a>
          </li>
        
          <li>
            <a href="/2019/09/18/redis-note-ch2/">《Redis开发与运维》第二章笔记</a>
          </li>
        
          <li>
            <a href="/2019/05/05/alogrithm/">alogrithm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Idealv<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>